// import RateLimiter from "./RateLimiter";
import Bottleneck from 'bottleneck'
import { TransactionReceipt } from 'web3-core'

import { Connection, Transaction, ContractDefinition, Contract } from '@solidstudio/solid.types'

import { Application } from '../../declarations'
import { IWeb3Wrapper } from '../web3-wrapper/IWeb3Wrapper'

// services
import { ContractDefinitions } from '../../services/contract-definitions/contract-definitions.class'
import { Transactions } from '../../services/transactions/transactions.class'
import { Connections } from '../../services/connections/connections.class'
import { Contracts } from '../../services/contracts/contracts.class'
import { Blocks } from '../../services/blocks/blocks.class'

import { IBlockchainProcessor } from './IBlockchainProcessor'
import { IPollingService } from './IPollingService'

const POLLING_INTERVAL = 1000 // TODO, move to factory, singleton class


export class BlockchainProcessor implements IBlockchainProcessor {
  asyncPolling: IBlockchainProcessor
  web3Wrapper: IWeb3Wrapper
  connection: Connection
  connectionService: Connections
  transactionsService: Transactions
  contractDefinitionsService: ContractDefinitions
  contractsService: Contracts
  blocksService: Blocks
  readonly rateLimitedGetTransactionReceipt: (txHash: string) => Promise<TransactionReceipt>
  readonly rateLimitedGetBlock: (blockNumber: number) => Promise<any>
  readonly rateLimitedGetBlockNumber: () => Promise<number>
  private readonly limiter: Bottleneck

  constructor(connection: Connection, app: Application, web3Wrapper: IWeb3Wrapper, pollingServiceFactory: IPollingService) {

    this.limiter = new Bottleneck({
      maxConcurrent: 1,
      minTime: 210
    })

    this.connectionService = app.service('connections')
    this.transactionsService = app.service('transactions')
    this.blocksService = app.service('blocks')
    this.contractDefinitionsService = app.service('contract-definitions')
    this.contractsService = app.service('contracts')
    this.connection = connection
    this.web3Wrapper = web3Wrapper
    this.rateLimitedGetTransactionReceipt = this.limiter.wrap(this.web3Wrapper.getTransactionReceipt.bind(this))
    this.rateLimitedGetBlockNumber = this.limiter.wrap(this.web3Wrapper.getBlockNumber.bind(this))
    this.rateLimitedGetBlock = this.limiter.wrap(this.web3Wrapper.getBlock.bind(this))

    this.asyncPolling = pollingServiceFactory.createPolling(async end => {
      await this.getBlocks()
      end()
    }, POLLING_INTERVAL)
  }

  async start() {
    this.asyncPolling.start()
  }

  async stop() {
    this.asyncPolling.stop()
  }

  private async getBlocks() {
    console.log('Starting getBlocks')
    try {
      // 100 en 100
      // get blocks
      // count transactions
      // split between operations
      // done..
      // approaches

      // 2 modes: isSynchronizing, then poll full, otherwise a job worker
      // Synchonizing...
      /**
       * Options, 
       * de 100 en 100, primero blocks
       * luego transactions
       * luego receipts
       * 
       * en Batch and retry until block is processed
       * then bulk save
       * 
       * Coordinator
       * 
       * Operations
       * getBlockNumber
       * getBlock
       * getTransaction
       * getTransactionReceipt
       * getCode
       * getTransactionCount* (could be skip for contract creation)
       * 
       * 
       * Parameters
       * 
       * Transactions per second = 5
       * 
       * Get block number
       * Get last block processed
       * Start from there
       * Get block
       * Save block
       * Get transactions
       * Save transactions
       * Get transaction receipts
       * Save transaction receipts
       * 
       * 
       */
      const blockNumber = await this.rateLimitedGetBlockNumber()
      const lastProcessedBlockNumber = this.connection.lastBlockNumberProcessed || 0
      const lastTransactionHashProcessed = this.connection.lastTransactionHashProcessed || ''
      console.log('lastProcessedBlockNumber inside', lastProcessedBlockNumber)
      if (lastProcessedBlockNumber > blockNumber) {
        console.error(
          'BlockNumberInconsistency: Last processed block in DB is higher than last block in the blockchain'
        )
        console.log(
          `BlockNumberInconsistency BlockNumber: ${blockNumber}, lastProcessedBlockNumber: ${lastProcessedBlockNumber}`
        )
        return
      }
      console.log('lastProcessedBlockNumber', lastProcessedBlockNumber)
      const blocksSequence = this.sequenceBetween(lastProcessedBlockNumber, blockNumber)
      for (const block of blocksSequence) {
        await this.processBlock(lastProcessedBlockNumber, lastTransactionHashProcessed, block)
      }
    } catch (error) {
      console.error(`Error processing blocks, retrying, ${error.message}, ${this.rateLimitedGetBlockNumber}`)
    }
  }

  async processBlock(lastBlockNumber: number, lastTransactionHashProcessed: string, blockNumber: number) {
    console.log(`Processing block ${blockNumber}`)
    const processedBlock = false
    const txProcessed = 0
    try {
      const block = await this.rateLimitedGetBlock(blockNumber)
      // TODO: Save block
      await this.blocksService.create(block); // careful cause this is not transactional, it would be nice to make it transactional from here..
      const transactions = block.transactions
      let transactionStart = 0
      console.log('Transactions', block.transactions)
      if (lastBlockNumber === blockNumber) {
        transactionStart = transactions.indexOf(lastTransactionHashProcessed)
        console.log('transactionStart', transactionStart)
        // If we are processing the first transaction
        if (transactionStart === -1) {
          transactionStart = 0
        }
      }
      for (const tx of transactions.slice(transactionStart, transactions.length)) {
        console.log('Transaction', tx)
        await this.processTransaction(lastTransactionHashProcessed, blockNumber, tx as any)
      }
    } catch (error) {
      console.error(`BlockProcessingError: Error processing block ${blockNumber}. Retrying`)
      console.log(`Error message: ${error.message}`)
    }
  }

  private async updateLastBlockProcessed(newLastTransactionHashProcessed: number, newLastProcessedBlockNumber: number) {
    if (this.connection.id) {
      await this.connectionService.update(this.connection.id, this.connection)
    }
  }

  private async processTransaction(lastTransactionHashProcessed: string, blockNumber: number, txHash: string) {
    console.log(`Processing transaction ${txHash}, blocknumber: ${blockNumber}`)
    if (lastTransactionHashProcessed === txHash) {
      return
    }
    const receipt = await this.rateLimitedGetTransactionReceipt(txHash)
    if (receipt) {
      //TODO NOW: I Need to push the transaction receipt 
      // this.connection.transactionReceipts.push(receipt)
      const newTransaction: Transaction = {
        ...receipt,
        connectionId: this.connection.id
      }

      await this.transactionsService.create(newTransaction)

      // TODO: This may be abstracted differently
      if (receipt.contractAddress) { // if it is contractCreation
        const runtimeByteCode = await this.web3Wrapper.getCode(receipt.contractAddress)
        const transactionCount = await this.web3Wrapper.getTransactionCount(receipt.contractAddress)

        console.log("runtimeByteCode from web3", runtimeByteCode)
        const contractDefinitionsResult = await this.contractDefinitionsService.find()
        const allExistingRuntimeBytecode = contractDefinitionsResult.data

        const itemFound = allExistingRuntimeBytecode.find((element: ContractDefinition) => {
          console.log("allExistingRuntimeBytecode find element", element.runtimeBycode)
          return element.runtimeBycode === runtimeByteCode
        });

        const newContract: Contract = {
          name: itemFound ? itemFound.name : "--",
          sourceCode: itemFound ? itemFound.sourceCode : "--",
          abi: itemFound ? itemFound.abi : [],
          bytecode: itemFound ? itemFound.bytecode : "",
          address: receipt.contractAddress,
          connectionId: this.connection.id || 0,
          creationDate: new Date().toLocaleDateString(),
          lastExecutionDate: new Date().toLocaleDateString(),
          transactionCount: transactionCount
        }

        this.contractsService.create(newContract)
      }

      if (this.connection.lastBlockNumberProcessed) {
        this.connection.lastBlockNumberProcessed = blockNumber
        this.connection.lastTransactionHashProcessed = txHash
        if (this.connection.id) {
          await this.connectionService.update(this.connection.id, this.connection)
        }
      }
    }
  }

  private sequenceBetween(start: number, end: number): number[] {
    return Array(end - start + 1)
      .fill(Number)
      .map((_, idx) => start + idx)
  }
}